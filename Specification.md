Your driver must have the following choices. Press option for the defined task (Use a while loop to receive option choices till option 0 is pressed. Ensure independence of working of all options e.g. if option 3 is pressed, option 2 is not needed)

0 : For exit

1 : For removal of comments ‐ print the comment free code on the console

2 : For printing the token list (on the console) generated by the lexer. This option performs lexical analysis and prints all tokens and lexemes line number wise. Here, the tokens are not passed to the parser, but printed on the console only. Each token appears in a new line along with the corresponding lexeme and line number. (invoke only lexer) [Ensure pretty printing with column justifications to increase readability]

3 : For parsing to verify the syntactic correctness of the input source code and printing the parse tree appropriately. This option prints all errors - lexical and syntactic, line number wise, on the console and prints parse tree in the file as mentioned in the command line below. (Invoke both lexer and parser).

4: For printing (on the console) the total time taken by your project code of lexer and parser to verify the syntactic correctness. Use <time.h> file as follows

-------------------------------------------------------------------------------------------------------------

#include <time.h>

clock_t start_time, end_time;

double total_CPU_time, total_CPU_time_in_seconds;

start_time = clock();

// invoke your lexer and parser here

end_time = clock();

total_CPU_time = (double) (end_time - start_time);

total_CPU_time_in_seconds = total_CPU_time / CLOCKS_PER_SEC;

// Print both total_CPU_time and total_CPU_time_in_seconds

---------------------------------------------------------------------------------------------------------

Perform actions appropriately by invoking appropriate functions.

Also during its execution, the driver displays necessary information regarding the implementation status of your work at the beginning on the console such as

(a) FIRST and FOLLOW set automated

(b) Only Lexical analyzer module developed

(c) Both lexical and syntax analysis modules implemented

(d) modules compile but give segmentation fault

(e) modules work with testcases 2, 3 and 4 only

(f) parse tree could not be constructed

and so on which ever is applicable.

Compilation:

The name of the make file should be makefile only as I will avoid using ‐f option always to make your file named something else (that includes searching for the file which is time taking). You can find documentation at the GNU website where you can learn how to write a make file (http://www.gnu.org/software/make/manual/make.html).

Please ensure compatibility with the GCC specifications provided in the recent notice.

Execution

The command line argument for execution of the driver should be as follows, for example

$./stage1exe  testcase.txt  parsetreeOutFile.txt

where stage1exe is the executable file generated after linking all the files (your makefile should be absolutely correct). The file testcase.txt is the sourcecode file in the given language to be analyzed and parsetreeOutFile.txt is the file containing parse tree printed as per the format specified earlier.

The inorder traversal for an n‐ary tree can be seen as follows

Leftmost child ‐‐> parent node‐‐> remaining siblings (excluding the leftmost)


Lexical Analyzer: Develop the lexical analyzer module of compiler for implementing the given language. This module takes as input the file containing user source code written in the given language and produces the tokens. The lexical analyzer module scans the input only once and collects all relevant information required by the other modules of compiler. The lexical analyzer ignores comments and white spaces, while recognizes the useful lexemes as valid tokens The lexical errors are reported by this module when it sees any symbol or pattern not belonging to the language. Your lexical analyzer must

Tokenize lexemes appropriately
Maintain all information collected during a single pass of the source code
Be efficient with respect to time and space complexity
Report lexical errors with line numbers appropriately
Syntax Analyzer: This module takes as input the token stream from the lexical analyzer module and verifies syntactic correctness of the source code. This uses predictive parser (using parsing table) to establish the syntactic structure of the source code. As the parser sees next token, verifies its correctness, it uses the token information to build a tree node and inserts appropriately in the parse tree corresponding to the input source code. If the source code (in given language) is syntactically correct, a corresponding parse tree is produced as the output. If the input is syntactically wrong, errors are reported appropriately. Your syntax analyzer (Parser) must

Ensure time and space efficiency and use a single pass of the token stream
Use predictive parser using parsing table
Produce as output the parse tree, if the source code is syntactically correct
Produce a list of syntax errors with appropriate messages and line numbers
Implementation Details

Use C language ( Linux/ Ubuntu based GCC) to implement the modules. 
Use of any other high level language or lexer/ parser generator packages is NOT allowed. 
Test your code with the test cases given in the language specification document. 
Generate more test cases and verify the correctness of your code. 
You will be given more test cases later. 
An appropriate interface support will be provided to you as you are through with the ground work.
Instead of starting coding, first spend time in designing the structure of your compiler code.


Your driver must have the following choices. Press option for the defined task (Use a while loop to receive option choices till option 0 is pressed. Ensure independence of working of all options e.g. if option 3 is pressed, option 2 is not needed)

0 : For exit

1 : For removal of comments ‐ print the comment free code on the console

2 : For printing the token list (on the console) generated by the lexer. This option performs lexical analysis and prints all tokens and lexemes line number wise. Here, the tokens are not passed to the parser, but printed on the console only. Each token appears in a new line along with the corresponding lexeme and line number. (invoke only lexer) [Ensure pretty printing with column justifications to increase readability]

3 : For parsing to verify the syntactic correctness of the input source code and printing the parse tree appropriately. This option prints all errors - lexical and syntactic, line number wise, on the console and prints parse tree in the file as mentioned in the command line below. (Invoke both lexer and parser).

4: For printing (on the console) the total time taken by your project code of lexer and parser to verify the syntactic correctness. Use <time.h> file as follows

-------------------------------------------------------------------------------------------------------------

#include <time.h>

clock_t start_time, end_time;

double total_CPU_time, total_CPU_time_in_seconds;

start_time = clock();

// invoke your lexer and parser here

end_time = clock();

total_CPU_time = (double) (end_time - start_time);

total_CPU_time_in_seconds = total_CPU_time / CLOCKS_PER_SEC;

// Print both total_CPU_time and total_CPU_time_in_seconds

---------------------------------------------------------------------------------------------------------

Perform actions appropriately by invoking appropriate functions.

Also during its execution, the driver displays necessary information regarding the implementation status of your work at the beginning on the console such as

(a) FIRST and FOLLOW set automated

(b) Only Lexical analyzer module developed

(c) Both lexical and syntax analysis modules implemented

(d) modules compile but give segmentation fault

(e) modules work with testcases 2, 3 and 4 only

(f) parse tree could not be constructed

and so on which ever is applicable.

Compilation:

The name of the make file should be makefile only as I will avoid using ‐f option always to make your file named something else (that includes searching for the file which is time taking). You can find documentation at the GNU website where you can learn how to write a make file (http://www.gnu.org/software/make/manual/make.html).

Please ensure compatibility with the GCC specifications provided in the recent notice.

Execution

The command line argument for execution of the driver should be as follows, for example

$./stage1exe  testcase.txt  parsetreeOutFile.txt

where stage1exe is the executable file generated after linking all the files (your makefile should be absolutely correct). The file testcase.txt is the sourcecode file in the given language to be analyzed and parsetreeOutFile.txt is the file containing parse tree printed as per the format specified earlier.

The inorder traversal for an n‐ary tree can be seen as follows

Leftmost child ‐‐> parent node‐‐> remaining siblings (excluding the leftmost)